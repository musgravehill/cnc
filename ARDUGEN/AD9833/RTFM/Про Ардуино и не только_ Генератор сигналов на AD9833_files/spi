// API callback
related_results_labels_thumbs({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-794788004739538112"},"updated":{"$t":"2019-04-15T11:47:52.329+03:00"},"category":[{"term":"ардуино"},{"term":"подключение"},{"term":"микросхема"},{"term":"программатор"},{"term":"энергопотребление"},{"term":"проект"},{"term":"энкодер вращения"},{"term":"lcd"},{"term":"spi"},{"term":"arduino pro mini"},{"term":"atmega328p"},{"term":"tiny"},{"term":"дребезг контактов"},{"term":"загрузчик"},{"term":"прерывания"},{"term":"digispark"},{"term":"midi"},{"term":"пьезоизлучатель"},{"term":"Светодиодная матрица"},{"term":"блютуз"},{"term":"датчик"},{"term":"фоторезистор"}],"title":{"type":"text","$t":"Про Ардуино и не только"},"subtitle":{"type":"html","$t":""},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"https:\/\/tsibrov.blogspot.com\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/794788004739538112\/posts\/default\/-\/spi?alt=json-in-script\u0026max-results=6"},{"rel":"alternate","type":"text/html","href":"https:\/\/tsibrov.blogspot.com\/search\/label\/spi"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"}],"author":[{"name":{"$t":"Владимир"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07943437233560370294"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"4"},"openSearch$startIndex":{"$t":"1"},"openSearch$itemsPerPage":{"$t":"6"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-794788004739538112.post-4650388700982764881"},"published":{"$t":"2018-10-10T18:28:00.000+03:00"},"updated":{"$t":"2019-03-20T22:40:47.113+03:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"spi"},{"scheme":"http://www.blogger.com/atom/ns#","term":"ардуино"},{"scheme":"http://www.blogger.com/atom/ns#","term":"программатор"}],"title":{"type":"text","$t":"Прошивка USBasp"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"http:\/\/1.bp.blogspot.com\/-rqTmB6jpMKg\/W6-_oMy3dqI\/AAAAAAAAAiA\/FlKGBMR_E90OEGqt9w-5b9qvXyg8VnukgCK4BGAYYCw\/s1600\/USBasp%2Bwarning.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg alt=\"avrdude: warning: cannot set sck period, please check for usbasp firmware update\" border=\"0\" height=\"192\" src=\"https:\/\/1.bp.blogspot.com\/-rqTmB6jpMKg\/W6-_oMy3dqI\/AAAAAAAAAiA\/FlKGBMR_E90OEGqt9w-5b9qvXyg8VnukgCK4BGAYYCw\/s640\/USBasp%2Bwarning.png\" title=\"\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EЕсли при использовании USBasp в логе avrdude у вас появляется сообщение\u003Cbr \/\u003E\u003Cb\u003Eavrdude: warning: cannot set sck period, please check for usbasp firmware update\u003C\/b\u003E, но при этом программатор исправно выполняет команды, то, скорее всего, проблема в устаревшей прошивке USBasp. В этой статье я по шагам расскажу, как обновить прошивку USBasp, используя Ардуино в качестве программатора.\u003Cbr \/\u003E\u003Ca name='more'\u003E\u003C\/a\u003E\u003Cbr \/\u003E\u003Ch3 style=\"text-align: left;\"\u003E1. Подготовка Ардуино\u003C\/h3\u003EВ качестве программатора можно использовать любую имеющуюся плату Ардуино. Для этого подключаем ее к компьютеру и загружаем в нее скетч ArduinoISP из стандартных примеров:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"https:\/\/2.bp.blogspot.com\/-x2vCNd2xVn4\/W09lmLgEqCI\/AAAAAAAAAcc\/vmMwthLFf-I4mtH5Eqn-xKiSDB-zVYO3ACPcBGAYYCw\/s1600\/ArduinoISP%2Bexample.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg alt=\"ArduinoISP sketch file\" border=\"0\" data-original-height=\"523\" data-original-width=\"592\" src=\"https:\/\/2.bp.blogspot.com\/-x2vCNd2xVn4\/W09lmLgEqCI\/AAAAAAAAAcc\/vmMwthLFf-I4mtH5Eqn-xKiSDB-zVYO3ACPcBGAYYCw\/s1600\/ArduinoISP%2Bexample.png\" title=\"\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch3 style=\"text-align: left;\"\u003E2. Подключение USBasp к Ардуино\u003C\/h3\u003EМикроконтроллеры семейства AVR, а значит и базирующиеся на них платы (как Ардуино, так и USBasp) поддерживают программирование по \u003Ca href=\"https:\/\/tsibrov.blogspot.com\/2018\/07\/arduino-as-isp.html#%D0%A7%D1%82%D0%BE%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B5%20ISP\"\u003EISP-технологии\u003C\/a\u003E\u0026nbsp;с использованием линий связи SPI. Поэтому сейчас нам нужно:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003Eсоединить выводы Ардуино MOSI, MISO, SCK GND и VCC (5В или 3.3В) с одноименными выводами USBasp;\u003C\/li\u003E\u003Cli\u003Eцифровой вывод 10 Ардуино подключить к выводу RESET USBasp;\u003C\/li\u003E\u003Cli\u003Eустановить электролитический конденсатор на 10мкФ между RESET\u0026nbsp;и GND Ардуино, чтобы предотвратить автоматическую перезагрузку. Хотя возможно будет работать и без конденсатора, зависит от используемой платы Ардуино.\u003C\/li\u003E\u003C\/ul\u003EДля подключения можете использовать как ICSP разъем\u0026nbsp;Ардуино, так и цифровые выводы - не принципиально. Я, например, взял MOSI, MISO, SCK, GND и VCC с ICSP разъема:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-FtnKcTbQw-Y\/W7zFj3YsSPI\/AAAAAAAAAiQ\/R77wXPRSZwAq1hMNVoCF6SPn3xMK7gKQQCK4BGAYYCw\/s1600\/20181005_080909.jpg\" imageanchor=\"1\"\u003E\u003Cimg alt=\"Обновление прошивки USBasp через Ардуино\" border=\"0\" height=\"360\" src=\"https:\/\/2.bp.blogspot.com\/-FtnKcTbQw-Y\/W7zFj3YsSPI\/AAAAAAAAAiQ\/R77wXPRSZwAq1hMNVoCF6SPn3xMK7gKQQCK4BGAYYCw\/s640\/20181005_080909.jpg\" title=\"\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EНа всякий случай приведу таблицу соответствия сигналов MOSI, MISO и SCK цифровым выводам различных плат Ардуино:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv\u003E\u003Ctable align=\"center\" style=\"height: 289px; width: 598px;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth style=\"width: 217px;\"\u003EПлата Ардуино\u003C\/th\u003E\u003Cth style=\"width: 117px;\"\u003EMOSI\u003C\/th\u003E\u003Cth style=\"width: 118px;\"\u003EMISO\u003C\/th\u003E\u003Cth style=\"width: 118px;\"\u003ESCK\u003C\/th\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 217px;\"\u003EUno, Duemilanove\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 117px;\"\u003E11 или ICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E12 или ICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E13 или ICSP-3\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 217px;\"\u003ENano\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 117px;\"\u003E11 или ICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E12 или ICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E13 или ICSP-3\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 217px;\"\u003EPro Mini\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 117px;\"\u003E11\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E12\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E13\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 217px;\"\u003EMega1280, Mega2560\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 117px;\"\u003E51 или ICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E50 или ICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E52 или ICSP-3\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 217px;\"\u003ELeonardo\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 117px;\"\u003EICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003EICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003EICSP-3\u0026nbsp;\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 217px;\"\u003EDue\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 117px;\"\u003EICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003EICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003EICSP-3\u0026nbsp;\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 217px;\"\u003EZero\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 117px;\"\u003EICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003EICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003EICSP-3\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 217px;\"\u003E101\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 117px;\"\u003E11 или ICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E12 или ICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 118px;\"\u003E13 или ICSP-3\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Ch3 style=\"text-align: left;\"\u003E3. Установка джампера JP2 на USBasp\u003C\/h3\u003EНа плате USBasp присутствуют 3 джампера, хотя распаян у вас, скорее всего, будет только JP1 - выбор напряжения питания программируемого микроконтроллера. \u003Cb\u003EДля прошивки USBasp (и любых других манипуляций с ним при помощи программатора) необходимо установить джампер JP2.\u003C\/b\u003E\u0026nbsp;Советую не мучиться с замыканием контактов подручными средствами и впаять пару штырьков, так будет надежней:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-IOqIbdOo9jQ\/W7zIdZ8GVdI\/AAAAAAAAAic\/7mecHCV0Tj4JyWbG2UVxz6U48ngSJgwWQCK4BGAYYCw\/s1600\/USBasp%2BJumper%2BFlash.jpg\" imageanchor=\"1\"\u003E\u003Cimg border=\"0\" height=\"228\" src=\"https:\/\/2.bp.blogspot.com\/-IOqIbdOo9jQ\/W7zIdZ8GVdI\/AAAAAAAAAic\/7mecHCV0Tj4JyWbG2UVxz6U48ngSJgwWQCK4BGAYYCw\/s640\/USBasp%2BJumper%2BFlash.jpg\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Ch3 style=\"text-align: left;\"\u003E4. Скачивание прошивки\u003C\/h3\u003E\u003Cdiv\u003EЗаходим на страничку автора USBasp\u0026nbsp;\u003Ca href=\"https:\/\/www.fischl.de\/usbasp\/\" target=\"_blank\"\u003Ehttps:\/\/www.fischl.de\/usbasp\/\u003C\/a\u003E и скачиваем последнюю версию прошивки в разделе\u0026nbsp;Download - Firmware and circuit. На момент написания данной статьи актуальной является версия от 28.05.2011. Файлы прошивки находятся внутри архива по пути \u003Ci\u003E\\usbasp.2011-05-28\\bin\\firmware\\\u003C\/i\u003E, их там три штуки, для каждого типа микроконтроллера (программатор USBasp может быть построен на базе ATmega8, ATmega48 или ATmega88). У меня в USBasp установлен микроконтроллер ATmega8, поэтому я буду использовать файл\u0026nbsp;usbasp.atmega8.2011-05-28.hex.\u003Cbr \/\u003E\u003Cbr \/\u003EПрошивать USBasp будем при помощи уже знакомого нам avrdude, входящего в состав IDE Arduino. Файл прошивки нужно поместить в каталог avrdude, чтобы потом не пришлось указывать полный путь к нему. Для этого запускаем Проводник Windows и переходим в каталог\u0026nbsp;\u003Ci\u003EArduino_dir\\hardware\\tools\\avr\\bin\\\u003C\/i\u003E, где\u0026nbsp;\u003Ci\u003EArduino_dir\u0026nbsp;\u003C\/i\u003E- это путь к IDE Arduino. В моем случае он выглядит так: \u003Ci\u003Ed:\\Arduino\\arduino-1.6.12\\hardware\\tools\\avr\\bin\\\u003C\/i\u003E, сюда я копирую файл usbasp.atmega8.2011-05-28.hex.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch3 style=\"text-align: left;\"\u003E5. Прошивка USBasp\u003C\/h3\u003EПосле копирования файла прошивки в каталог avrdude поместите курсор в адресную строку Проводника, удалите из нее путь, введите cmd и нажмите Enter.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/3.bp.blogspot.com\/-SvjW9WeU_a0\/W7zWkRR_IHI\/AAAAAAAAAio\/qf56coGr4rUx5LQwdk6MdtdExRvUL6-5gCK4BGAYYCw\/s1600\/avrdude%2Bcmd.png\" imageanchor=\"1\"\u003E\u003Cimg border=\"0\" height=\"211\" src=\"https:\/\/3.bp.blogspot.com\/-SvjW9WeU_a0\/W7zWkRR_IHI\/AAAAAAAAAio\/qf56coGr4rUx5LQwdk6MdtdExRvUL6-5gCK4BGAYYCw\/s640\/avrdude%2Bcmd.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Cbr \/\u003EЗапустится интерпретатор командной строки. В нем нужно ввести команду:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003Eavrdude -C ..\\etc\\avrdude.conf -p m8 -c arduino -P com18 -b 19200 -U flash:w:usbasp.atmega8.2011-05-28.hex\u003C\/b\u003E\u003Cbr \/\u003E\u003Cbr \/\u003EНе забудьте проверить и с корректировать ее параметры:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E-C ..\\etc\\avrdude.conf\u003C\/b\u003E\u0026nbsp;- путь к конфигурационному файлу (без этого параметра avrdude иногда ругается: can't open config file \"\": Invalid argument)\u003Cbr \/\u003E\u003Cb\u003E\u003Cbr \/\u003E\u003C\/b\u003E\u003Cb\u003E-p m8\u003C\/b\u003E - определяет тип микроконтроллера. Значение m8 сообщает avrdude о том, что мы собираемся работать с ATmega8. Если у вас в USBasp установлен ATmega48 или ATmega88, то замените это значение на m48 или m88 соответственно.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E-P com18\u003C\/b\u003E - определяет COM порт, присвоенный плате Ардуино. У меня это com18, вам нужно подставить свое значение.\u003Cbr \/\u003E\u003Cb\u003E\u003Cbr \/\u003E\u003C\/b\u003E\u003Cb\u003E-U flash:w:usbasp.atmega8.2011-05-28.hex\u003C\/b\u003E - определяет действие, которое мы хотим выполнить. В данном случае мы хотим записать в FLASH память данные из файла usbasp.atmega8.2011-05-28.hex. При необходимости скорректируйте имя файла прошивки в соответствии с типом микроконтроллера в USBasp.\u003Cbr \/\u003E\u003Cbr \/\u003EУбедитесь, что команда набрана верно и программатор правильно соединен с Ардуино. После этого подключаем Ардуино к компьютеру и нажимаем Enter в интерпретаторе командной строки. Должен отобразиться прогресс перезаписи содержимого FLASH памяти, а затем сообщение об успешном выполнении команды - avrdude done. Thank you:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/3.bp.blogspot.com\/-H5g0APyL8ps\/W74WX11_sAI\/AAAAAAAAAi0\/Bo7jry4vnhoGVBkivhdUcwSFmBm6_1AIgCK4BGAYYCw\/s1600\/USBasp%2Bflashing.png\" imageanchor=\"1\"\u003E\u003Cimg border=\"0\" height=\"350\" src=\"https:\/\/3.bp.blogspot.com\/-H5g0APyL8ps\/W74WX11_sAI\/AAAAAAAAAi0\/Bo7jry4vnhoGVBkivhdUcwSFmBm6_1AIgCK4BGAYYCw\/s640\/USBasp%2Bflashing.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EТеперь можно отключить USBasp от Ардуино, снять джампер JP2 и проверить работу программатора. Сообщения\u0026nbsp;\u003Cb\u003Eavrdude: warning: cannot set sck period, please check for usbasp firmware update\u003C\/b\u003E больше быть не должно.\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/tsibrov.blogspot.com\/feeds\/4650388700982764881\/comments\/default","title":"Комментарии к сообщению"},{"rel":"replies","type":"text/html","href":"https:\/\/tsibrov.blogspot.com\/2018\/10\/usbasp-firmware-update.html#comment-form","title":"Комментарии: 33"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/794788004739538112\/posts\/default\/4650388700982764881"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/794788004739538112\/posts\/default\/4650388700982764881"},{"rel":"alternate","type":"text/html","href":"https:\/\/tsibrov.blogspot.com\/2018\/10\/usbasp-firmware-update.html","title":"Прошивка USBasp"}],"author":[{"name":{"$t":"Владимир"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07943437233560370294"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/1.bp.blogspot.com\/-rqTmB6jpMKg\/W6-_oMy3dqI\/AAAAAAAAAiA\/FlKGBMR_E90OEGqt9w-5b9qvXyg8VnukgCK4BGAYYCw\/s72-c\/USBasp%2Bwarning.png","height":"72","width":"72"},"thr$total":{"$t":"33"}},{"id":{"$t":"tag:blogger.com,1999:blog-794788004739538112.post-3658531361444533218"},"published":{"$t":"2018-08-19T15:13:00.001+03:00"},"updated":{"$t":"2019-02-07T20:35:11.392+03:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"spi"},{"scheme":"http://www.blogger.com/atom/ns#","term":"ардуино"},{"scheme":"http://www.blogger.com/atom/ns#","term":"программатор"}],"title":{"type":"text","$t":"Что такое Фьюзы. Чтение и запись фьюзов Ардуино"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003EСегодня я хочу рассказать о том, что такое фьюзы, за что они отвечают и как их можно прочитать и записать в Ардуино. Рекомендую также заглянуть в \u003Ca href=\"https:\/\/tsibrov.blogspot.com\/2018\/07\/arduino-as-isp.html\" target=\"_blank\"\u003Eпредыдущую публикацию\u003C\/a\u003E, т.к. работа с фьюзами возможна только через программатор.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ca name='more'\u003E\u003C\/a\u003E\u003Cbr \/\u003EФьюзы (от английского Fuse bits) - это конфигурационные биты микроконтроллера, отвечающие за его предварительную настройку. Эти биты расположены в отдельном адресном пространстве, доступном только при программировании. Биты объединяются в конфигурационные байты и их состав зависит от конкретной модели микроконтроллера.\u003Cbr \/\u003E\u003Cbr \/\u003EПри работе с конфигурационными битами нужно помнить один важный момент: \u003Cb\u003Eесли бит содержит логическую единицу, то это означает что он не запрограммирован, соответственно, запрограммированный конфигурационный бит содержит логический ноль\u003C\/b\u003E. Такая логика была заложена фирмой Atmel и основана на принципе хранения данных в EEPROM: чистая микросхема памяти содержит во всех ячейках единицы, а термин запрограммирована по отношению к такой ячейке означает, что в нее записали ноль.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ch2 style=\"text-align: left;\"\u003EФьюзы ATmega328 \/ ATmega328p\u003C\/h2\u003EМикроконтроллеры ATmega328 и ATmega328p, на базе которых построено большинство плат семейства Ардуино, имеют 3 байта конфигурации: младший, старший и дополнительный. Их описание приведено ниже в таблицах.\u003Cbr \/\u003E\u003Cbr \/\u003EМладший конфигурационный байт ATmega328\/P\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" style=\"height: 213px;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth style=\"text-align: left; width: 50px;\"\u003EНомер бита\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 115px;\"\u003EНавание\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 230px;\"\u003EОписание\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 180px;\"\u003EЗначение по умолчанию\u003C\/th\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E7\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ECKDIV8\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003EDivide clock by 8\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E0 (запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E6\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ECKOUT\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003EClock output\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E5\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ESUT1\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003ESelect start-up time\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E4\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ESUT0\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003ESelect start-up time\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E0 (запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E3\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ECKSEL3\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003ESelect Clock source\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E0 (запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E2\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ECKSEL2\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003ESelect Clock source\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E0 (запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E1\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ECKSEL1\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003ESelect Clock source\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E0\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ECKSEL0\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003ESelect Clock source\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E0 (запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Cbr \/\u003EСтарший конфигурационный байт ATmega328\/P\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" style=\"height: 213px;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth style=\"text-align: left; width: 50px;\"\u003EНомер бита\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 115px;\"\u003EНавание\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 230px;\"\u003EОписание\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 180px;\"\u003EЗначение по умолчанию\u003C\/th\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E7\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ERSTDISBL\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003EExternal Reset Disable\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E6\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003EDWEN\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003EdebugWIRE Enable\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E5\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003ESPIEN\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003EEnable Serial Program and Data Downloading\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E0 (запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E4\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003EWDTON\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003EWatchdog Timer Always On\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E3\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003EEESAVE\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003EEEPROM memory is preserved through the Chip Erase\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E2\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003EBOOTSZ1\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003ESelect Boot Size\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E0 (запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E1\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003EBOOTSZ0\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003ESelect Boot Size\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E0 (запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: left; width: 50px;\"\u003E0\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 115px;\"\u003EBOOTRST\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 230px;\"\u003ESelect Reset Vector\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E0 (запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Cbr \/\u003EДополнительный конфигурационный байт ATmega328\/P\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" style=\"height: 213px;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth style=\"text-align: left; width: 50px;\"\u003EНомер бита\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 115px;\"\u003EНавание\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 230px;\"\u003EОписание\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 180px;\"\u003EЗначение по умолчанию\u003C\/th\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 50px;\"\u003E7\u003C\/td\u003E\u003Ctd style=\"width: 115px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"width: 230px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 50px;\"\u003E6\u003C\/td\u003E\u003Ctd style=\"width: 115px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"width: 230px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 50px;\"\u003E5\u003C\/td\u003E\u003Ctd style=\"width: 115px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"width: 230px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 50px;\"\u003E4\u003C\/td\u003E\u003Ctd style=\"width: 115px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"width: 230px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 50px;\"\u003E3\u003C\/td\u003E\u003Ctd style=\"width: 115px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"width: 230px;\"\u003E-\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 50px;\"\u003E2\u003C\/td\u003E\u003Ctd style=\"width: 115px;\"\u003EBODLEVEL2\u003C\/td\u003E\u003Ctd style=\"width: 230px;\"\u003EBrown-out Detector trigger level\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 50px;\"\u003E1\u003C\/td\u003E\u003Ctd style=\"width: 115px;\"\u003EBODLEVEL1\u003C\/td\u003E\u003Ctd style=\"width: 230px;\"\u003EBrown-out Detector trigger level\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 50px;\"\u003E0\u003C\/td\u003E\u003Ctd style=\"width: 115px;\"\u003EBODLEVEL0\u003C\/td\u003E\u003Ctd style=\"width: 230px;\"\u003EBrown-out Detector trigger level\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 180px;\"\u003E1 (не запрограммирован)\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Cbr \/\u003EТаким образом, значения конфигурационных байтов в ATmega328\/P по умолчанию: Low: 0x62, High: 0xD9, Extended: 0xFF. Обратите внимание, это значения именно для \"чистого\" микроконтроллера ATmega328\/P , а не для Ардуино. Значения фьюзов для Ардуино можно найти в файле\u0026nbsp;\u003Ci\u003EArduino_dir\\hardware\\arduino\\avr\\Boards.txt\u003C\/i\u003E, где\u0026nbsp;\u003Ci\u003EArduino_dir\u003C\/i\u003E - это путь к IDE Arduino. Откройте файл в текстовом редакторе и найдите интересующую плату по названию, чуть ниже будет информация о фьюзах:\u003Cbr \/\u003E\u003Cbr \/\u003Euno.name=Arduino\/Genuino Uno\u003Cbr \/\u003E...\u003Cbr \/\u003Euno.bootloader.low_fuses=0xFF\u003Cbr \/\u003Euno.bootloader.high_fuses=0xDE\u003Cbr \/\u003Euno.bootloader.extended_fuses=0x05\u003Cbr \/\u003E\u003Cbr \/\u003EДля расшифровки шестнадцатеричных значений конфигурационных байтов удобно использовать онлайн калькулятор\u0026nbsp;\u003Ca href=\"http:\/\/www.engbedded.com\/fusecalc\/\" target=\"_blank\"\u003EEngbedded Atmel AVR® Fuse Calculator\u003C\/a\u003E:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/1.bp.blogspot.com\/-ZDJ_hUDk10w\/W3EzbILZDOI\/AAAAAAAAAeU\/5U16wDMeiEYbcBYswC7oIgT2_MMDEs_VgCK4BGAYYCw\/s1600\/Online%2Bfuse%2Bcalculator.png\" imageanchor=\"1\"\u003E\u003Cimg alt=\"Engbedded Atmel AVR® Fuse Calculator\" border=\"0\" height=\"400\" src=\"https:\/\/1.bp.blogspot.com\/-ZDJ_hUDk10w\/W3EzbILZDOI\/AAAAAAAAAeU\/5U16wDMeiEYbcBYswC7oIgT2_MMDEs_VgCK4BGAYYCw\/s640\/Online%2Bfuse%2Bcalculator.png\" title=\"\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EВыберите модель микроконтроллера и введите значения фьюзов в соответствующие поля внизу страницы в разделе Current settings - введенные значения будут моментально расшифрованы и представлены в удобном виде. И, наоборот, можно изменить конфигурацию битов в разделах\u0026nbsp;Manual fuse bits configuration и\u0026nbsp;Feature configuration и получить значения конфигурационных байтов для записи в микроконтроллер.\u003Cbr \/\u003E\u003Cbr \/\u003EРассмотрим назначение конфигурационных битов более подробно.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ch4 style=\"text-align: left;\"\u003ECKDIV8\u003C\/h4\u003E\u003Cdiv\u003EДанный бит отвечает за деление тактовой частоты на 8. Он определяет начальное значение регистра делителя частоты: если бит не запрограммирован, то регистр делителя будет сброшен в \"0000\"; если бит CKDIV8 запрограммирован, то в регистре будет установлено значение \"0011\", что обеспечит деление тактовой частоты на 8. Однако вне зависимости от значения фьюза CKDIV8 значение делителя может быть изменено программой в любой момент.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch4 style=\"text-align: left;\"\u003ECKOUT\u003C\/h4\u003E\u003Cdiv\u003EATmega328\/p позволяет выводить тактовую частоту на цифровой вывод CLKO (digital pin 8 на Ардуино Уно). Для этого конфигурационный бит CKOUT должен быть запрограммирован. Данная функция может быть полезна при использовании таковой частоты микроконтроллера внешними устройствами. При использовании делителя системной частоты на вывод CLKO также будет поступать пониженная частота.\u003C\/div\u003E\u003Cbr \/\u003E\u003Ch4 style=\"text-align: left;\"\u003ESUT\u003C\/h4\u003EКонфигурационные биты SUT совместно с битами CKSEL определяют длительность задержки при старте микроконтроллера. Задержка необходима для того, чтобы источник тактовой частоты стабилизировался после подачи питания и вошел в свой рабочий режим. Величина задержки зависит от выбранного источника и составляет от 0 до 65мс. Конкретные значения можно найти в даташите.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ca href=\"http:\/\/www.blogger.com\/blogger.g?blogID=794788004739538112\" name=\"CKSEL\"\u003E\u003C\/a\u003E \u003Cbr \/\u003E\u003Ch4 style=\"text-align: left;\"\u003ECKSEL\u003C\/h4\u003E\u003Cdiv\u003EСовременные микроконтроллеры способны работать с различными источниками тактового сигнала. Выбор источника осуществляется установкой конфигурационных битов CKSEL. В таблице ниже приведены источники тактового сигнала, поддерживаемые микроконтроллерами ATmega328 \/ ATmega328P, и соответствующие им значения CKSEL.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" style=\"height: 213px; width: 442.933px;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth style=\"text-align: left; width: 343px;\"\u003EИсточник тактового сигнала\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 90.9333px;\"\u003EЗначение CKSEL3..0\u003C\/th\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 343px;\"\u003EЭкономичный кварцевый генератор\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 90.9333px;\"\u003E1111-1000\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 343px;\"\u003EКварцевый генератор\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 90.9333px;\"\u003E0111-0110\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 343px;\"\u003EНизкочастотный кварцевый генератор\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 90.9333px;\"\u003E0101-0100\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 343px;\"\u003EВнутренний RC-генератор на 128кГц\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 90.9333px;\"\u003E0011\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 343px;\"\u003EВнутренний калиброванный RC-генератор\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 90.9333px;\"\u003E0010\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 343px;\"\u003EВнешний сигнал синхронизации\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 90.9333px;\"\u003E0000\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 343px;\"\u003EЗарезервировано\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 90.9333px;\"\u003E0001\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Ca href=\"http:\/\/www.blogger.com\/blogger.g?blogID=794788004739538112\" name=\"RSTDISBL\"\u003E\u003C\/a\u003E \u003Cbr \/\u003E\u003Ch4 style=\"text-align: left;\"\u003ERSTDISBL\u003C\/h4\u003EФьюз\u0026nbsp;RSTDISBL управляет работой цифрового вывода микроконтроллера, совмещенного с входом внешнего сброса. Если RSTDISBL запрограммирован,\u0026nbsp; то вывод может быть использован как обычный цифровой пин ввода\/вывода. Если фьюз RSTDISBL не запрограммирован, то вывод используется для внешнего сигнала сброса: низкий уровень напряжения на нем приводит к генерации сигнала сброса микроконтроллера. Отключение внешнего сброса может быть оправдано при работе с микроконтроллерами, имеющими небольшое количество выводов, в других случаях лучше не трогать этот фьюз.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ch4 style=\"text-align: left;\"\u003EDWEN\u003C\/h4\u003E\u003C\/div\u003E\u003Cdiv\u003EБит DWEN разрешает\/запрещает работу отладочного интерфейса debugWire.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch4 style=\"text-align: left;\"\u003ESPIEN\u003C\/h4\u003E\u003Cdiv\u003EДанный бит разрешает\/запрещает программирование по интерфейсу SPI. По умолчанию он запрограммирован и лучше не менять значение данного фьюза, как и значение RSTDISBL.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch4 style=\"text-align: left;\"\u003EWDTON\u003C\/h4\u003E\u003Cdiv\u003EЕсли запрограммировать конфигурационный бит\u0026nbsp;WDTON, то сторожевой таймер начнет свою работу сразу после подачи питания на микроконтроллер. Работу таймера нельзя будет запретить программно и при его переполнении будет генерироваться сигнал сброса. Если данный фьюз не запрограммирован, то работой сторожевого таймера можно управлять программно, в том числе настроить его на генерацию прерывания, сигнала сброса или того и другого.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch4 style=\"text-align: left;\"\u003EEESAVE\u003C\/h4\u003E\u003Cdiv\u003EДанный бит определяет влияние команды \"Стирание кристалла\" на EEPROM-память: если бит запрограммирован, то при выполнении команды Chip Erase будут очищены Flash, SRAM и Lock-биты, а содержимое EEPROM затронуто не будет. В противном случае содержимое EEPROM также будет стерто.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch4 style=\"text-align: left;\"\u003EBOOTSZ\u003C\/h4\u003E\u003Cdiv\u003EКонфигурационные биты BOOTSZ определяют размер FLASH памяти микроконтроллера, резервируемой для загрузчика. Значения битов BOOTSZ и соответствующие им размеры указаны в таблице ниже. По умолчанию резервируется максимальный размер - 2048 слов.\u003C\/div\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" style=\"height: 213px; width: 445px;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth style=\"text-align: left; width: 271px;\"\u003EНачало секции загрузчика\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 335.5px;\"\u003EРазмер секции (слов)\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 187.5px;\"\u003EЗначение BOOTSZ1..0\u003C\/th\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 271px;\"\u003E0x3F00\u003C\/td\u003E\u003Ctd style=\"width: 335.5px;\"\u003E256\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 187.5px;\"\u003E11\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 271px;\"\u003E0x3E00\u003C\/td\u003E\u003Ctd style=\"width: 335.5px;\"\u003E512\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 187.5px;\"\u003E10\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 271px;\"\u003E0x3C00\u003C\/td\u003E\u003Ctd style=\"width: 335.5px;\"\u003E1024\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 187.5px;\"\u003E01\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 271px;\"\u003E0x3800\u003C\/td\u003E\u003Ctd style=\"width: 335.5px;\"\u003E2048\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 187.5px;\"\u003E00\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Ch4 style=\"text-align: left;\"\u003EBOOTRST\u003C\/h4\u003E\u003Cdiv\u003EОпределяет положение вектора сброса. Если бит не запрограммирован, то вектор сброса располагается по адресу 0x0000, выполнение программы начнется именно с этого адреса. Если бит BOOTRST запрограммирован, то выполнение программы начнется с адреса начала секции загрузчика.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch4 style=\"text-align: left;\"\u003EBODLEVEL\u003C\/h4\u003E\u003Cdiv\u003EКонфигурационные биты\u0026nbsp;BODLEVEL определяют порог срабатывания схемы BOD (Brown-Out Detection), которая отслеживает уровень напряжения источника питания. Если работа схемы BOD разрешена, то при снижении напряжения питания ниже установленного порога она переводит микроконтроллер в состояние сброса. Когда напряжение питания вновь увеличивается до порогового значения (данный порог чуть выше предыдущего за счет наличия гистерезиса), сигнал сброса снимается и происходит запуск микроконтроллера. Комбинации битов BODLEVEL и соответствующие им пороговые значения приведены в таблице:\u003C\/div\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" style=\"height: 213px; width: 445px;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth style=\"text-align: left; width: 271px;\"\u003EПорог срабатывания схемы BOD (В)\u003C\/th\u003E\u003Cth style=\"text-align: left; width: 187.5px;\"\u003EЗначение BODLEVEL2..0\u003C\/th\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 271px;\"\u003EСхема BOD выключена\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 187.5px;\"\u003E111\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 271px;\"\u003EVcc = 1.8\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 187.5px;\"\u003E110\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 271px;\"\u003EVcc = 2.7\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 187.5px;\"\u003E101\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr style=\"text-align: left;\"\u003E\u003Ctd style=\"width: 271px;\"\u003EVcc = 4.3\u003C\/td\u003E\u003Ctd style=\"text-align: left; width: 187.5px;\"\u003E100\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Cdiv\u003E\u003Cbr \/\u003EТеперь можно понять начальное состояние микроконтроллеров ATmega328\/P, в каком они поставляются с завода: микроконтроллер сконфигурирован на работу с внутренним RC генератором на 8МГц, при этом прошитый бит CKDIV8 обеспечивает деление частоты генератора на 8; внешний сброс (по низкому уровню на выводе Reset) не запрещен; разрешено программирование по интерфейсу SPI; для загрузчика отведена область памяти 2048 слов; стартовый адрес программы 0x0000; схема контроля питания отключена.\u003Cbr \/\u003E\u003Cbr \/\u003EВ Ардуино Уно фьюзы микроконтроллера изменены таким образом, чтобы он был настроен на работу с экономичным кварцевым генератором без делителя частоты; для загрузчика отводится 256 слов; прошитый бит BOOTRST назначает стартовым адресом адрес начала секции загрузчика; порог срабатывания схемы BOD составляет 2.7В.\u003Cbr \/\u003E\u003Cbr \/\u003EРазобравшись с назначением фьюзов можно перейти от теории к практике: попробуем прочитать и записать фьюзы Ардуино.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: left;\"\u003EЧтение фьюзов Ардуино\u003C\/h2\u003EВ \u003Ca href=\"https:\/\/tsibrov.blogspot.com\/2018\/07\/arduino-as-isp.html\"\u003Eпредыдущей публикации\u003C\/a\u003E я рассказал о том, как превратить Ардуино в ISP программатор. И сейчас он нам пригодится для работы с фьюзами. Поэтому готовим программатор и подключаем к нему плату, из которой будем считывать фьюзы.\u003Cbr \/\u003E\u003Cbr \/\u003EВ среде разработки Ардуино нет инструментов для чтения\/записи фьюзов. Разве что процедура записи загрузчика включает в себя установку фьюзов, значения которых берутся из упомянутого ранее файла\u0026nbsp;Boards.txt. Но в состав IDE входит программа Avrdude, предназначенная для прошивки AVR микроконтроллеров, ей-то мы и воспользуемся. Avrdude - консольная программа, работать мы с ней будем через командную строку, поэтому запускаем проводник и переходим в папку с программой. У меня IDE Arduino расположена на диске D и путь к Avrdude выглядит следующим образом:\u0026nbsp;\u003Ci\u003ED:\\Arduino\\arduino-1.6.12\\hardware\\tools\\avr\\bin\u003C\/i\u003E.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-p1bnLmAGasg\/W2_iB6U3V3I\/AAAAAAAAAdk\/5Z35tVVEahoZHpnOTzacQwOr3AoQxFbvwCK4BGAYYCw\/s1600\/Arduino%2Bpath%2Bto%2Bavrdude.png\" imageanchor=\"1\"\u003E\u003Cimg border=\"0\" height=\"336\" src=\"https:\/\/4.bp.blogspot.com\/-p1bnLmAGasg\/W2_iB6U3V3I\/AAAAAAAAAdk\/5Z35tVVEahoZHpnOTzacQwOr3AoQxFbvwCK4BGAYYCw\/s640\/Arduino%2Bpath%2Bto%2Bavrdude.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EНаходясь в этой папке нужно поместить курсор в адресную строку, удалить из нее путь, ввести cmd и нажать Enter. Откроется окно интерпретатора командной строки:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-GVMqg8qpTfE\/W3B_GDszNBI\/AAAAAAAAAd8\/uoJKgtzeLFc_Dhnv-xkKoE1J0Tvv91FGQCK4BGAYYCw\/s1600\/cmd%2Bwith%2Bavrdude%2Bpath.png\" imageanchor=\"1\"\u003E\u003Cimg border=\"0\" height=\"180\" src=\"https:\/\/2.bp.blogspot.com\/-GVMqg8qpTfE\/W3B_GDszNBI\/AAAAAAAAAd8\/uoJKgtzeLFc_Dhnv-xkKoE1J0Tvv91FGQCK4BGAYYCw\/s640\/cmd%2Bwith%2Bavrdude%2Bpath.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EПосле этого подключаем программатор к компьютеру и вводим в командной строке следующую команду:\u003Cbr \/\u003E\u003Cbr \/\u003Eavrdude -c arduino -p m328p -P com26 -b 19200 -U lfuse:r:-:h\u003Cbr \/\u003E\u003Cbr \/\u003EПеред выполнением команды проверьте и скорректируйте ее параметры:\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003E-c \u0026lt;programmer\u0026gt; - в качестве \u0026lt;programmer\u0026gt; указывает псевдоним используемого программатора, в нашем случае arduino.\u003C\/li\u003E\u003Cli\u003E-p \u0026lt;partno\u0026gt; - указывает тип микроконтроллера, m328p - это ATmega328p.\u003C\/li\u003E\u003Cli\u003E-P \u0026lt;port\u0026gt; - указывает используемый программатором порт.\u003C\/li\u003E\u003Cli\u003E-b\u0026nbsp;\u0026lt;baudrate\u0026gt; - позволяет переопределить указанную для программатора в конфигурации программы скорость подключения по интерфейсу RS-232.\u003C\/li\u003E\u003Cli\u003E-U \u0026lt;memtype\u0026gt;:r|w|v:\u0026lt;filename\u0026gt;[:format] - комплексная опция для указания производимой с памятью операции (чтение. запись, проверка). -U lfuse:r:-:h означает, что мы хотим прочитать содержимое младшего байта конфигурации, считанное значение выводим на экран в шестнадцатеричном виде.\u003C\/li\u003E\u003C\/ul\u003E\u003Cdiv\u003EБолее подробную информацию о параметрах запусках avrdude можно найти по ссылке\u0026nbsp;\u003Ca href=\"https:\/\/ph0en1x.net\/77-avrdude-full-howto-samples-options-gui-linux.html\" target=\"_blank\"\u003Ehttps:\/\/ph0en1x.net\/77-avrdude-full-howto-samples-options-gui-linux.html\u003C\/a\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EНиже приведен мой результат выполнения данной команды:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-ilh9BphMacE\/W3HULeJ1kZI\/AAAAAAAAAes\/IVPq-GbiyIkRpwDOphrZYhP5AbFoGpZVgCK4BGAYYCw\/s1600\/avrdude%2Breading%2Bfuses.png\" imageanchor=\"1\"\u003E\u003Cimg alt=\"avrdude чтение фьюзов Ардуино\" border=\"0\" height=\"340\" src=\"https:\/\/2.bp.blogspot.com\/-ilh9BphMacE\/W3HULeJ1kZI\/AAAAAAAAAes\/IVPq-GbiyIkRpwDOphrZYhP5AbFoGpZVgCK4BGAYYCw\/s640\/avrdude%2Breading%2Bfuses.png\" title=\"\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003C\/div\u003EКак видно из скриншота, младший конфигурационный байт моей Arduino Uno содержит значение 0xFF. Кроме запрошенного значения avrdude показал также значения всех трех конфигурационных байт. Это произошло потому, что мы не отключили safemode, это можно сделать, добавив в команду параметр -u. Остальные два конфигурационных байта также соответствуют значениям, приведенным в файле Boards.txt. Если у кого-то возникнут сомнения по поводу соответствия дополнительного конфигурационного байта, то загляните в его описание выше - биты с 3 по 7 не используются и содержат \"1\", поэтому вместо 0x05 мы считываем значение 0xFD.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ch2 style=\"text-align: left;\"\u003EЗапись фьюзов Ардуино\u003C\/h2\u003E\u003Cdiv\u003EПолагаю, из приведенного выше описания фьюзов должно быть понятно, что при работе с ними нужно быть очень осторожным. В противном случае вы рискуете \"залочить\"\u0026nbsp; микроконтроллер, т.е. привести в такое состояние, когда его уже нельзя будет перепрограммировать (без дополнительного оборудования). Поэтому будьте внимательны, изменяя фьюзы микроконтроллера.\u003Cbr \/\u003E\u003Cbr \/\u003EДавайте в качестве примера попробуем запретить работу схемы BOD в Ардуино Уно. Обратившись к приведенному выше описанию конфигурационных байтов или к онлайн калькулятору\u0026nbsp;\u003Ca href=\"http:\/\/www.engbedded.com\/fusecalc\/\" target=\"_blank\"\u003EEngbedded Atmel AVR® Fuse Calculator\u003C\/a\u003E, мы видим, что за работу схемы BOD в ATmega328\/P отвечают фьюзы BODLEVEL и для ее запрета нужно записать в дополнительный конфигурационный байт\u0026nbsp;значение 0xFF. Это можно сделать следующей командой avrdude:\u003Cbr \/\u003E\u003Cbr \/\u003Eavrdude -c arduino -p m328p -P com26 -b 19200 -U efuse:w:0xFF:m\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/1.bp.blogspot.com\/--F4KecNov9U\/W3laiYKYDoI\/AAAAAAAAAfQ\/ovoCIobw5owRKiI2rGwD9CeLayYeqFrQgCK4BGAYYCw\/s1600\/avrdude%2Bwrite%2Bfuses.png\" imageanchor=\"1\"\u003E\u003Cimg alt=\"avrdude запись фьюзов Ардуино\" border=\"0\" height=\"340\" src=\"https:\/\/1.bp.blogspot.com\/--F4KecNov9U\/W3laiYKYDoI\/AAAAAAAAAfQ\/ovoCIobw5owRKiI2rGwD9CeLayYeqFrQgCK4BGAYYCw\/s640\/avrdude%2Bwrite%2Bfuses.png\" title=\"\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EИз скриншота видно, что avrdude сначала выполняет запись байта efuse, после чего производит контрольное считывание и сообщает об успешном выполнении операции.\u003Cbr \/\u003E\u003Cbr \/\u003EВ принципе нет\u0026nbsp;ничего сложного в работе с конфигурационными битами. Главное быть внимательным при их изменении, чтобы не залочить микроконтроллер.\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/tsibrov.blogspot.com\/feeds\/3658531361444533218\/comments\/default","title":"Комментарии к сообщению"},{"rel":"replies","type":"text/html","href":"https:\/\/tsibrov.blogspot.com\/2018\/08\/fuse-bits.html#comment-form","title":"Комментарии: 0"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/794788004739538112\/posts\/default\/3658531361444533218"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/794788004739538112\/posts\/default\/3658531361444533218"},{"rel":"alternate","type":"text/html","href":"https:\/\/tsibrov.blogspot.com\/2018\/08\/fuse-bits.html","title":"Что такое Фьюзы. Чтение и запись фьюзов Ардуино"}],"author":[{"name":{"$t":"Владимир"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07943437233560370294"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/1.bp.blogspot.com\/-ZDJ_hUDk10w\/W3EzbILZDOI\/AAAAAAAAAeU\/5U16wDMeiEYbcBYswC7oIgT2_MMDEs_VgCK4BGAYYCw\/s72-c\/Online%2Bfuse%2Bcalculator.png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-794788004739538112.post-4775141513209704836"},"published":{"$t":"2018-07-19T12:41:00.000+03:00"},"updated":{"$t":"2019-01-07T17:26:41.400+03:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"spi"},{"scheme":"http://www.blogger.com/atom/ns#","term":"ардуино"},{"scheme":"http://www.blogger.com/atom/ns#","term":"загрузчик"},{"scheme":"http://www.blogger.com/atom/ns#","term":"программатор"}],"title":{"type":"text","$t":"Arduino as ISP - программатор из Ардуино"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-pedZ8KfTh6o\/W3lXvAJstUI\/AAAAAAAAAfE\/ge8OlCSXbksD60IahY89GKguBa1BOSpTQCK4BGAYYCw\/s1600\/Arduino%2BAs%2BISP.png\" imageanchor=\"1\"\u003E\u003Cimg alt=\"Arduino as ISP - программатор из Ардуино\" border=\"0\" height=\"223\" src=\"https:\/\/4.bp.blogspot.com\/-pedZ8KfTh6o\/W3lXvAJstUI\/AAAAAAAAAfE\/ge8OlCSXbksD60IahY89GKguBa1BOSpTQCK4BGAYYCw\/s320\/Arduino%2BAs%2BISP.png\" title=\"\" width=\"320\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EЕсть у меня пара идей для будущих публикаций, но в них будет использоваться программатор. Поэтому сегодня я расскажу о том, как превратить Ардуино в ISP программатор, для чего он нужен и как им пользоваться. А в качестве примера будет описана процедура прошивки загрузчика в Ардуино.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ca name='more'\u003E\u003C\/a\u003E\u003Ca href=\"http:\/\/www.blogger.com\/blogger.g?blogID=794788004739538112\" name=\"Что такое ISP\"\u003E\u003C\/a\u003E \u003Ch2 style=\"text-align: left;\"\u003EЧто такое ISP?\u003C\/h2\u003E\u003Cbr \/\u003EISP (In-System Programming) расшифровывается как внутрисхемное программирование. Это технология, которая позволяет программировать микроконтроллер, установленный в устройство. До появления этой технологии микроконтроллеры программировались перед установкой в устройство, а для их перепрограммирования требовалось их извлечение из устройства.\u003Cbr \/\u003E\u003Cbr \/\u003EСуществует 2 основных подхода внутрисхемного программирования:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003EС использованием программатора. В этом случае программатор работает напрямую с памятью микроконтроллера, самостоятельно размещая байты прошивки по нужным адресам. Микроконтроллер в этом процессе не участвует.\u003C\/li\u003E\u003Cli\u003EС использованием загрузчика. Загрузчик, он же бутлоадер (от английского bootloader) - это программа, записанная обычно в конце ПЗУ микроконтроллера, которая берет на себя функции программатора. При включении микроконтроллера управление сначала\u0026nbsp;передается загрузчику. Он проверяет наличие определенных условий, сообщающих о необходимости перейти в режим программирования. Если условия не выполнены, то управление передается основной программе, в противном случае загрузчик принимает данные по заранее определенному интерфейсу и размещает их в ПЗУ. Таким образом микроконтроллер перепрограммирует сам себя.\u003C\/li\u003E\u003C\/ul\u003E\u003Cdiv\u003EОдной из важнейших особенностей Ардуино является возможность программирования непосредственно через USB порт, без дополнительного программатора. Сразу после включения Ардуино запускается загрузчик, который работает несколько секунд. Если за это время загрузчик получает команду программирования от IDE по последовательному интерфейсу UART, то он принимает и загружает новую программу в память микроконтроллера.\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EИспользование загрузчика существенно упрощает процесс перепрограммирования микроконтроллера, что особенно полезно при отладке. Но за удобство приходится платить. Во-первых, загрузчик занимает часть ПЗУ и для программы пользователя остается меньший объем памяти. Во-вторых, загрузчик не может изменить Fuse-биты и Lock-биты (в отличие от программаторов). Ну и, конечно, не обойтись без программатора, если вы хотите обновить бутлоадер или загрузить его в чистый МК. Таким образом существует ряд задач, которые могут быть выполнены только с использованием программатора. Если же у вас нет аппаратного программатора, то вместо него можно воспользоваться Ардуино, о чем и будет рассказано дальше.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ch2 style=\"text-align: left;\"\u003EArduino as ISP. Прошивка загрузчика в Ардуино.\u003C\/h2\u003EИтак, мы решили превратить Ардуино в программатор. Для примера попробуем прошить загрузчик в целевую плату Ардуино. Сначала подготовим плату, которую будем использовать в качестве программатора. Для этого загрузим в нее скетч ArduinoISP, его можно найти в стандартных примерах:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-x2vCNd2xVn4\/W09lmLgEqCI\/AAAAAAAAAcU\/k_K3_mmrpmk8fYTxPfa63YxM3r4fy8o2gCK4BGAYYCw\/s1600\/ArduinoISP%2Bexample.png\" imageanchor=\"1\"\u003E\u003Cimg alt=\"ArduinoISP sketch file\" border=\"0\" src=\"https:\/\/2.bp.blogspot.com\/-x2vCNd2xVn4\/W09lmLgEqCI\/AAAAAAAAAcU\/k_K3_mmrpmk8fYTxPfa63YxM3r4fy8o2gCK4BGAYYCw\/s1600\/ArduinoISP%2Bexample.png\" title=\"\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EТеперь подсоединим к ней плату, в которую хотим прошить загрузчик. При прошивке используются линии SPI (Serial Peripheral Interface - последовательный периферийный интерфейс). Выводы\u0026nbsp;MOSI, MISO и SCK обеих плат должны быть соединены, а вывод SS Ардуино-программатора подключается к выводу Reset целевой платы. И еще 2 провода нужны чтобы запитать целевую плату. Также может потребоваться предотвратить автоматическую перезагрузку платы-программатора, для этого между ее выводами Reset и GND нужно установить электролитический конденсатор на 10мкФ. Сначала можно попробовать без конденсатора, если же прошивка не начнется, то попробуйте добавить в схему конденсатор. По моим наблюдениям конденсатор нужен при использовании дешевых Ардуино-клонов (без контроллера ATmega8u2) в качестве программатора.\u003Cbr \/\u003E\u003Cbr \/\u003EЕсли мы работаем с двумя платами Arduino Uno, то схема их подключения может выглядеть следующим образом:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-iIBlw9Dzg4Y\/W0YF8pv3sQI\/AAAAAAAAAcA\/_jyNwhdLhMgwEQJU3CWP6Dsa7JfPuLqgQCK4BGAYYCw\/s1600\/Two%2BArduino%2BUNO%2BISP.png\" imageanchor=\"1\"\u003E\u003Cimg alt=\"Arduino as ISP схема подключения\" border=\"0\" height=\"640\" src=\"https:\/\/2.bp.blogspot.com\/-iIBlw9Dzg4Y\/W0YF8pv3sQI\/AAAAAAAAAcA\/_jyNwhdLhMgwEQJU3CWP6Dsa7JfPuLqgQCK4BGAYYCw\/s640\/Two%2BArduino%2BUNO%2BISP.png\" title=\"\" width=\"428\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003EЕсли используются не Uno, а другие платы Ардуино, то перед подключением программатора к целевой плате необходимо уточнить расположение на них выводов MOSI, MISO и SCK. Их расположение для различных плат приведено ниже в таблице. Как вы можете видеть, не на всех платах Ардуино линии SPI мультиплексированны с цифровыми выводами, поэтому для подключения к данному интерфейсу необходимо использовать разъем ICSP. Ниже показан пример подключения Uno в качестве программатора к плате Nano через ICSP разъем.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv\u003E\u003Ctable align=\"center\" style=\"height: 213px; width: 651px;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth style=\"width: 202px;\"\u003EПлата Ардуино\u003C\/th\u003E\u003Cth style=\"width: 108px;\"\u003EMOSI\u003C\/th\u003E\u003Cth style=\"width: 109px;\"\u003EMISO\u003C\/th\u003E\u003Cth style=\"width: 109px;\"\u003ESCK\u003C\/th\u003E\u003Cth style=\"text-align: right; width: 89px;\"\u003EУровень\u003C\/th\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 202px;\"\u003EUno, Duemilanove\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 108px;\"\u003E11 или ICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E12 или ICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E13 или ICSP-3\u003C\/td\u003E\u003Ctd style=\"text-align: right; width: 89px;\"\u003E5В\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 202px;\"\u003ENano\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 108px;\"\u003E11 или ICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E12 или ICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E13 или ICSP-3\u003C\/td\u003E\u003Ctd style=\"text-align: right; width: 89px;\"\u003E5В\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 202px;\"\u003EPro Mini\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 108px;\"\u003E11\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E12\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E13\u003C\/td\u003E\u003Ctd style=\"text-align: right; width: 89px;\"\u003E3.3В или 5В\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 202px;\"\u003EMega1280, Mega2560\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 108px;\"\u003E51 или ICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E50 или ICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E52 или ICSP-3\u003C\/td\u003E\u003Ctd style=\"text-align: right; width: 89px;\"\u003E5В\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 202px;\"\u003ELeonardo\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 108px;\"\u003EICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003EICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003EICSP-3\u0026nbsp;\u003C\/td\u003E\u003Ctd style=\"text-align: right; width: 89px;\"\u003E5В\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 202px;\"\u003EDue\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 108px;\"\u003EICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003EICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003EICSP-3\u0026nbsp;\u003C\/td\u003E\u003Ctd style=\"text-align: right; width: 89px;\"\u003E3.3В\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 202px;\"\u003EZero\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 108px;\"\u003EICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003EICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003EICSP-3\u003C\/td\u003E\u003Ctd style=\"text-align: right; width: 89px;\"\u003E3.3В\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"width: 202px;\"\u003E101\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 108px;\"\u003E11 или ICSP-4\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E12 или ICSP-1\u003C\/td\u003E\u003Ctd style=\"text-align: center; width: 109px;\"\u003E13 или ICSP-3\u003C\/td\u003E\u003Ctd style=\"text-align: right; width: 89px;\"\u003E3.3В\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/1.bp.blogspot.com\/-sw2q0ntUMEs\/W09oDWaeamI\/AAAAAAAAAck\/zDL2DPkM9w0T6Ii5ZQ6Pw4FhrA5DEwQUgCK4BGAYYCw\/s1600\/Arduino%2BUno%2Band%2BNano%2BISP.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg alt=\"Arduino as ISP схема подключения Nano\" border=\"0\" height=\"398\" src=\"https:\/\/1.bp.blogspot.com\/-sw2q0ntUMEs\/W09oDWaeamI\/AAAAAAAAAck\/zDL2DPkM9w0T6Ii5ZQ6Pw4FhrA5DEwQUgCK4BGAYYCw\/s640\/Arduino%2BUno%2Band%2BNano%2BISP.png\" title=\"\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003EПодключение Uno в качестве программатора к плате Nano через ICSP\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003C\/div\u003EОбратите внимание на нумерацию выводов ICSP платы Nano: она начинается с правого нижнего угла. Поэтому на приведенной схеме Arduino Nano перевернута.\u003Cbr \/\u003E\u003Cbr \/\u003EТеперь необходимо вернуться в Arduino IDE и изменить в ней параметры:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Col style=\"text-align: left;\"\u003E\u003Cli\u003EВ меню \u003Ci\u003EИнструменты \u0026gt; Плата\u003C\/i\u003E выбираем вариант, соответствующий нашей \u003Cu\u003Eцелевой плате\u003C\/u\u003E.\u003C\/li\u003E\u003Cli\u003EВ меню \u003Ci\u003EИнструменты \u0026gt; Программатор\u003C\/i\u003E выбираем Arduino as ISP.\u003C\/li\u003E\u003C\/ol\u003E\u003Cbr \/\u003EПодключаем плату-программатор к компьютеру, открытый в данный момент скетч значения не имеет, выбираем пункт меню \u003Ci\u003EИнструменты \u0026gt; Записать загрузчик\u003C\/i\u003E\u0026nbsp;и дожидаемся сообщения об успешном завершении операции. На этом прошивка бутлоадера в Ардуино завершена. Кроме того процедура прошивки бутлоадера включает в себя установку фьюзов микроконтроллера. Подробнее о фьюзах будет рассказано в \u003Ca href=\"https:\/\/tsibrov.blogspot.com\/2018\/08\/fuse-bits.html\" target=\"_blank\"\u003Eследующей публикации\u003C\/a\u003E.\u003Cbr \/\u003E\u003Cbr \/\u003EРезюмируя вышеописанное, выделим основные шаги для прошивки загрузчика с использованием Ардуино в качестве ISP программатора:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003EЗапускаем Arduino IDE, открываем из примеров скетч ArduinoISP и загружаем его в плату Ардуино, которую будем использовать как программатор.\u003C\/li\u003E\u003Cli\u003EПодключаем к Ардуино-программатору целевую плату по приведенной схеме.\u003C\/li\u003E\u003Cli\u003EМеняем плату в Arduino IDE на целевую.\u003C\/li\u003E\u003Cli\u003EВыбираем в IDE программатор Arduino as ISP.\u003C\/li\u003E\u003Cli\u003EЗаписываем загрузчик в целевую плату командой из меню IDE.\u003C\/li\u003E\u003C\/ul\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch2 style=\"text-align: left;\"\u003EПрошивка скетча с использованием Arduino as ISP\u003C\/h2\u003EЕще один пример использования программатора - это загрузка скетча в целевую плату. Разумеется, это проще сделать привычным способом, подключив ее напрямую к компьютеру, но это может оказаться невозможным, например, при выходе из строя контроллера ATmega8u2\/ATmega16u2 или преобразователя USB\/UART. Если при этом основной микроконтроллер Ардуино остался рабочим, то мы можем прошить его, используя программатор. Для этого выполняем все шаги, описанные выше, но на последнем этапе вместо записи загрузчика необходимо:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003EОткрыть в Arduino IDE интересующий скетч.\u003C\/li\u003E\u003Cli\u003EЗагрузить скетч в целевую плату командой из меню IDE: \u003Ci\u003EСкетч \u0026gt; Загрузить через программатор\u003C\/i\u003E.\u003C\/li\u003E\u003C\/ul\u003E\u003Cdiv\u003EТаким образом можно подарить вторую жизнь плате Ардуино, которую компьютер уже не видит через USB.\u003C\/div\u003E\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003C\/ul\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/tsibrov.blogspot.com\/feeds\/4775141513209704836\/comments\/default","title":"Комментарии к сообщению"},{"rel":"replies","type":"text/html","href":"https:\/\/tsibrov.blogspot.com\/2018\/07\/arduino-as-isp.html#comment-form","title":"Комментарии: 0"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/794788004739538112\/posts\/default\/4775141513209704836"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/794788004739538112\/posts\/default\/4775141513209704836"},{"rel":"alternate","type":"text/html","href":"https:\/\/tsibrov.blogspot.com\/2018\/07\/arduino-as-isp.html","title":"Arduino as ISP - программатор из Ардуино"}],"author":[{"name":{"$t":"Владимир"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07943437233560370294"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/4.bp.blogspot.com\/-pedZ8KfTh6o\/W3lXvAJstUI\/AAAAAAAAAfE\/ge8OlCSXbksD60IahY89GKguBa1BOSpTQCK4BGAYYCw\/s72-c\/Arduino%2BAs%2BISP.png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-794788004739538112.post-4256446582282147909"},"published":{"$t":"2018-06-24T18:43:00.000+03:00"},"updated":{"$t":"2019-03-20T21:26:28.459+03:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"lcd"},{"scheme":"http://www.blogger.com/atom/ns#","term":"spi"},{"scheme":"http://www.blogger.com/atom/ns#","term":"ардуино"},{"scheme":"http://www.blogger.com/atom/ns#","term":"микросхема"},{"scheme":"http://www.blogger.com/atom/ns#","term":"подключение"},{"scheme":"http://www.blogger.com/atom/ns#","term":"проект"},{"scheme":"http://www.blogger.com/atom/ns#","term":"энкодер вращения"}],"title":{"type":"text","$t":"Генератор сигналов на AD9833"},"content":{"type":"html","$t":"\u003Cdiv dir=\"ltr\" style=\"text-align: left;\" trbidi=\"on\"\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-tN6CdYwMg6s\/WyQMYhQrmVI\/AAAAAAAAAbA\/Mr2xHivY5dkQ95C8l6JXwj_KS1MYMSFDQCK4BGAYYCw\/s1600\/AD9833.jpg\" imageanchor=\"1\"\u003E\u003Cimg alt=\"Генератор AD9833\" border=\"0\" height=\"320\" src=\"https:\/\/4.bp.blogspot.com\/-tN6CdYwMg6s\/WyQMYhQrmVI\/AAAAAAAAAbA\/Mr2xHivY5dkQ95C8l6JXwj_KS1MYMSFDQCK4BGAYYCw\/s320\/AD9833.jpg\" title=\"AD9833 подключение к Ардуино\" width=\"320\" \/\u003E\u003C\/a\u003E\u003C\/div\u003EAD9833 - это программируемый генератор сигналов с низким энергопотреблением. Позволяет генерировать сигналы с частотой до 12.5МГц синусоидальной, треугольной и прямоугольной формы. Программирование осуществляется с использованием трехпроводного интерфейса SPI и не составляет труда. Ниже приведены основные характеристики микросхемы:\u003Cbr \/\u003E\u003Ca name='more'\u003E\u003C\/a\u003E\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003EЦифровое программирование частоты и фазы.\u003C\/li\u003E\u003Cli\u003EПотребляемая мощность 12.65 мВт при напряжении 3 В.\u003C\/li\u003E\u003Cli\u003EДиапазон выходных частот от 0 МГц до 12.5 МГц.\u003C\/li\u003E\u003Cli\u003EРазрешение 28 бит (0.1 Гц при частоте опорного сигнала 25 МГц).\u003C\/li\u003E\u003Cli\u003EСинусоидальные, треугольные и прямоугольные выходные колебания.\u003C\/li\u003E\u003Cli\u003EНапряжение питания от 2.3 В до 5.5 В.\u003C\/li\u003E\u003Cli\u003EТрехпроводной интерфейс SPI.\u003C\/li\u003E\u003Cli\u003EРасширенный температурный диапазон: от –40°C до +105°C.\u003C\/li\u003E\u003Cli\u003EОпция пониженного энергопотребления.\u003C\/li\u003E\u003C\/ul\u003E\u003Cbr \/\u003EБолее подробную информацию вы можете найти в \u003Ca href=\"http:\/\/clc.la\/ad9833_datasheet\" target=\"_blank\"\u003Eдаташите\u003C\/a\u003E. В характеристиках также заявлено, что микросхема не требует внешних компонентов, но здесь производитель лукавит: обвязка и источник опорной частоты все же нужны. На Али продаются модули AD9833 с необходимой обвязкой и кварцевым генератором на 25 МГц, как раз с таким модулем я и собираюсь экспериментировать. Данный модуль имеет следующие выводы:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003EVCC – плюс питания для цифровых и аналоговых цепей генератора.\u003C\/li\u003E\u003Cli\u003EDGND – цифровая земля.\u003C\/li\u003E\u003Cli\u003ESDATA – вход данных интерфейса SPI. Передача осуществляется 16-битными словами.\u003C\/li\u003E\u003Cli\u003ESCLK – вход тактового сигнала SPI. Используется второй режим работы: (CPOL = 1, CPHA = 0).\u003C\/li\u003E\u003Cli\u003EFSYNC – выбор микросхемы. Перед началом передачи данных должен быть установлен в 0, по завершении в 1.\u003C\/li\u003E\u003Cli\u003EAGND – аналоговая земля.\u003C\/li\u003E\u003Cli\u003EOUT – выход генератора.\u003C\/li\u003E\u003C\/ul\u003EПопробуем подключить этот модуль к Ардуино и научиться им управлять. Для начала ознакомимся с его функциональной схемой:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg alt=\"Функциональная схема AD9833\" border=\"0\" height=\"368\" src=\"https:\/\/2.bp.blogspot.com\/-69XH7GVpwgw\/WwpkdLAdMsI\/AAAAAAAAAac\/ZSRJJFMHR5gC4B_WuFojx1aAdrnlTiKDQCK4BGAYYCw\/s640\/AD9833_Functional_Diagram.png\" title=\"\" width=\"640\" \/\u003E\u003C\/div\u003E\u003Cbr \/\u003EAD9833 состоит из следующих основных частей: два регистра выбора частоты, аккумулятор фазы, два регистра выбора фазы и сумматор смещения фазы (вместе эти компоненты составляют генератор с цифровым управлением - NCO), SIN ROM для преобразования информации о фазе в амплитуду и 10-разрядный цифро-аналоговый преобразователь.\u003Cbr \/\u003E\u003Cbr \/\u003EИз схемы видно, что данные с интерфейса SPI передаются в управляющий регистр, регистры выбора фазы и частоты. Именно они определяют сигнал на выходе генератора. И программирование генератора сводится к изменению содержимого указанных регистров.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ch3 style=\"text-align: left;\"\u003EУправляющий регистр\u003C\/h3\u003EЭто 16-разрядный регистр, управляющий работой генератора. Подробное описание его битов приведено ниже в таблице. Схема из даташита также наглядно демонстрирует их назначение:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-AiANhL6sEUA\/Wwpk8roXhxI\/AAAAAAAAAao\/fgu6ISaPJC4bdzyz8lYUsTZr4F_3XHStwCK4BGAYYCw\/s1600\/AD9833_Control_Bits.png\" imageanchor=\"1\"\u003E\u003Cimg border=\"0\" height=\"316\" src=\"https:\/\/2.bp.blogspot.com\/-AiANhL6sEUA\/Wwpk8roXhxI\/AAAAAAAAAao\/fgu6ISaPJC4bdzyz8lYUsTZr4F_3XHStwCK4BGAYYCw\/s640\/AD9833_Control_Bits.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003C\/div\u003E\u003Ctable style=\"width: 100%;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth width=\"36\"\u003EБит \u003C\/th\u003E\u003Cth width=\"124\"\u003EНазвание \u003C\/th\u003E\u003Cth width=\"485\"\u003EНазначение \u003C\/th\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E15, 14 \u003C\/td\u003E\u003Ctd\u003EDB15, DB14 \u003C\/td\u003E\u003Ctd\u003EЧтобы AD9833 понял, что принятое по SPI 16-битное слово содержит новое значение для управляющего регистра, два старших бита в слове должны быть установлены в 0. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E13 \u003C\/td\u003E\u003Ctd\u003EB28 \u003C\/td\u003E\u003Ctd\u003EРегистры частоты AD9833 имеют разрядность 28 бит, поэтому для изменения их содержимого требуется передача двух 16-битных слов. Однако в некоторых случаях требуется изменить только старшую или младшую часть регистра частоты. Здесь и используется данный признак: B28 = 1 говорит о том, что необходимо обновить регистр частоты целиком и его новое значение будет передано двумя последовательными записями. Первая запись содержит 14 младших бит, вторая 14 старших бит. Первые два бита в обеих записях определяют регистр частоты, в который будет записано передаваемое значение и должны быть одинаковыми. Обновление регистра частоты происходит после получения полного слова, поэтому запись промежуточного значения в регистр исключена. B28 = 0 позволяет обновить отдельно старшую или младшую часть регистра. Какая именно часть будет изменена определяется управляющим битом HLB. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E12 \u003C\/td\u003E\u003Ctd\u003EHLB \u003C\/td\u003E\u003Ctd\u003EБит HLB определяет, какая из частей регистра частоты (младшая или старшая) будет перезаписана. Используется при B28 = 0. При B28 = 1 значение этого бита игнорируется. HLB = 1 позволяет обновить старшие 14 бит регистра частоты; HLB = 0 позволяет обновить младшие 14 бит регистра частоты. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E11 \u003C\/td\u003E\u003Ctd\u003EFSELECT \u003C\/td\u003E\u003Ctd\u003EБит FSELECT определяет, какой из регистров используется в аккумуляторе фазы – FREQ0 или FREQ1. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E10 \u003C\/td\u003E\u003Ctd\u003EPSELECT \u003C\/td\u003E\u003Ctd\u003EБит PSELECT определяет, данные какого из регистров PHASE0 или PHASE1 добавляются к выходу аккумулятора фазы. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E9 \u003C\/td\u003E\u003Ctd\u003EЗарезервирован \u003C\/td\u003E\u003Ctd\u003EДанный бит зарезервирован и должен быть установлен в 0. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E8 \u003C\/td\u003E\u003Ctd\u003ERESET \u003C\/td\u003E\u003Ctd\u003ERESET = 1 сбрасывает внутренние регистры генератора в 0. Сброс не затрагивает регистры управления, частоты и фазы. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E7 \u003C\/td\u003E\u003Ctd\u003ESLEEP1 \u003C\/td\u003E\u003Ctd\u003EПри SLEEP1 = 1 запрещается внутреннее тактирование, приостанавливается работа NCO и выход генератора остается в своем текущем состоянии. При SLEEP1 = 0 тактирование разрешено. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E6 \u003C\/td\u003E\u003Ctd\u003ESLEEP12 \u003C\/td\u003E\u003Ctd\u003EПри SLEEP12 = 1 отключается внутренний ЦАП. Это может быть полезно для генерации прямоугольных импульсов, при которой не требуется выполнение цифро-аналоговых преобразований. При SLEEP12 = 0 внутренний ЦАП активен. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E5 \u003C\/td\u003E\u003Ctd\u003EOPBITEN \u003C\/td\u003E\u003Ctd\u003EДанный бит вместе с битом MODE управляют выходом генератора. При OPBITEN = 1 внутренний ЦАП отключается от выхода VOUT и для генерации выходного сигнала используется значение старшего значащего бита с входа ЦАП, что позволяет получить на выходе генератора прямоугольные импульсы. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E4 \u003C\/td\u003E\u003Ctd\u003EЗарезервирован \u003C\/td\u003E\u003Ctd\u003EДанный бит зарезервирован и должен быть установлен в 0. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E3 \u003C\/td\u003E\u003Ctd\u003EDIV2 \u003C\/td\u003E\u003Ctd\u003EИспользуется в паре со значением OPBITEN = 1. При DIV2 = 1 значение старшего значащего бита данных с входа ЦАП подается напрямую на выход VOUT. DIV2 = 0 позволяет задействовать делитель частоты и уменьшить частоту выходного сигнала вдвое. При OPBITEN = 0 значение данного бита игнорируется. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E2 \u003C\/td\u003E\u003Ctd\u003EЗарезервирован \u003C\/td\u003E\u003Ctd\u003EДанный бит зарезервирован и должен быть установлен в 0. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E1 \u003C\/td\u003E\u003Ctd\u003EMODE \u003C\/td\u003E\u003Ctd\u003EДанный бит вместе с битом OPBITEN управляют выходом генератора. При OPBITEN = 1 бит MODE должен быть установлен в 0. Значение MODE = 0 позволяет получить на выходе генератора синусоидальный сигнал. При MODE = 1 на выходе будет треугольный сигнал. \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd\u003E0 \u003C\/td\u003E\u003Ctd\u003EЗарезервирован \u003C\/td\u003E\u003Ctd\u003EДанный бит зарезервирован и должен быть установлен в 0. \u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cdiv\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: left;\"\u003EИ для лучшего понимания назначения битов OPBITEN, MODE и DIV2 я приведу таблицу с их допустимыми комбинациями и формой результирующих сигналов на выходе:\u003C\/div\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Ctable style=\"width: 100%;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Cth width=\"73px\"\u003EOPBITEN \u003C\/th\u003E\u003Cth width=\"73px\"\u003EMODE \u003C\/th\u003E\u003Cth width=\"73px\"\u003EDIV2 \u003C\/th\u003E\u003Cth\u003EСигнал на выходе VOUT \u003C\/th\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\" width=\"73\"\u003E0 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\" width=\"73\"\u003E0 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\" width=\"73\"\u003EX \u003C\/td\u003E\u003Ctd\u003EСинусоидальный \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E0 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\"\u003E1 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\"\u003EX \u003C\/td\u003E\u003Ctd\u003EТреугольный \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E1 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\"\u003E0 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\"\u003E0 \u003C\/td\u003E\u003Ctd\u003EПрямоугольный с частотой F\/2 \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E1 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\"\u003E0 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\"\u003E1 \u003C\/td\u003E\u003Ctd\u003EПрямоугольный с частотой F \u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E1 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\"\u003E1 \u003C\/td\u003E\u003Ctd style=\"text-align: center;\"\u003EX \u003C\/td\u003E\u003Ctd\u003EЗарезервировано \u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: left;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ch3 style=\"text-align: left;\"\u003EРегистры частоты и фазы\u003C\/h3\u003E\u003Cdiv\u003EГенератор AD9833 имеет 2 регистра частоты и 2 регистра фазы разрядностью 28 бит и 12 бит соответственно.\u0026nbsp;\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EВыбор активного регистра частоты осуществляется установкой управляющего бита FSELECT: при FSELECT = 0 активным является FREQ0; при FSELECT = 1 активен регистр FREQ1. Результирующая частота на выходе генератора определяется следующим образом:\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E(F\u003Csub\u003EMCLK\u003C\/sub\u003E \/ 2\u003Csup\u003E28\u003C\/sup\u003E) * FREQREG,\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003Eгде F\u003Csub\u003EMCLK\u003C\/sub\u003E – это опорная частота, FREQREG – значение, загруженное в активный регистр частоты. Таким образом, если мы хотим получить на выходе генератора сигнал с частотой 400Гц при опорной частоте 25МГц, в активный регистр\u0026nbsp; должно быть загружено значение:\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EFREQREG = F\u003Csub\u003EOUT\u003C\/sub\u003E*2\u003Csup\u003E28\u003C\/sup\u003E \/ F\u003Csub\u003EMCLK\u003C\/sub\u003E = 400Гц * 2\u003Csup\u003E28\u003C\/sup\u003E \/ 25МГц ≈ 4295\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EДля того чтобы загрузить значение FREQREG в регистр частоты необходимо старшие биты передаваемого по SPI значения установить в 01 для загрузки в FREQ0 или 10 для загрузки в FREQ1. Напомню, что общение с AD9833 осуществляется по SPI 16-битными словами.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EФаза выходного сигнала определяется следующим образом:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E(2π \/ 2\u003Csup\u003E12\u003C\/sup\u003E) * PHASEREG\u003Cbr \/\u003E\u003Cbr \/\u003Eсоответственно, значение для регистра фазы вычисляется по формуле:\u003Cbr \/\u003E\u003Cbr \/\u003EPHASEREG = PHASE*2\u003Csup\u003E12\u003C\/sup\u003E\u0026nbsp;\/ 2π\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EВ приведенных формулах PHASEREG – это значение активного регистра фазы. Выбор активного регистра осуществляется установкой управляющего бита PSELECT: при PSELECT = 0 активным является PHASE0; при PSELECT = 1 активен регистр PHASE1.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EПри записи нового значения в регистр фазы старшие биты должны быть установлены в 11, а выбор регистра, в который должно быть записано значение, осуществляется установкой бита 13: при нулевом его значении будет обновлен регистр PHASE0; при установке указанного бита в 1 будет обновлен регистр PHASE1. 12й бит не используется, а биты с 0 по 11 содержат значение для регистра фазы.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003EРазрядность регистра частоты в 28 бит при опорной частоте 25МГц обеспечивает шаг 0.1Гц для установки частоты сигнала на выходе. А 12-битный регистр фазы обеспечивает разрешение 2π\/4096.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Ch3 style=\"text-align: left;\"\u003EТестовая программа для AD9833 на Ардуино\u003C\/h3\u003E\u003C\/div\u003E\u003Cdiv\u003EТеперь мы можем написать первую программу для AD9833. Схема подключения модуля AD9833 к Ардуино и скетч приведены ниже.\u003C\/div\u003E\u003C\/div\u003E\u003Cdiv\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-Dwk89e02Dxg\/WwqLVPujOgI\/AAAAAAAAAa0\/17AslGl1lskkS4x3Duxy8vYhbHdlWqK2QCK4BGAYYCw\/s1600\/AD9833_Arduino.png\" imageanchor=\"1\"\u003E\u003Cimg alt=\"Схема подключения AD9833 к Ардуино\" border=\"0\" height=\"428\" src=\"https:\/\/4.bp.blogspot.com\/-Dwk89e02Dxg\/WwqLVPujOgI\/AAAAAAAAAa0\/17AslGl1lskkS4x3Duxy8vYhbHdlWqK2QCK4BGAYYCw\/s640\/AD9833_Arduino.png\" title=\"\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003EС подключением все просто: общение с модулем происходит по интерфейсу SPI, для которого на Ардуино отведены следующие пины:\u003Cbr \/\u003E\u003Cbr \/\u003ED10 - SS (Slave Select - выбор ведомого), к нему подключаем вывод FSYNC модуля.\u003Cbr \/\u003ED11 - MOSI (Master Out Slave In - выход ведущего, вход ведомого), к нему подключаем вывод SDATA.\u003Cbr \/\u003ED13 - SCK (Serial Clock - Тактовый сигнал), к нему подключаем вывод SCLK.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"hljs\" style=\"background: rgb(255 , 255 , 255); color: rgb(67 , 79 , 84); display: block; overflow-x: auto; padding: 0.5em;\"\u003E\u003Cspan class=\"hljs-meta\" style=\"color: rgb(67 , 79 , 84);\"\u003E#\u003Cspan class=\"hljs-meta-keyword\" style=\"color: rgb(114 , 142 , 0);\"\u003Einclude\u003C\/span\u003E \u003Cspan class=\"hljs-meta-string\"\u003E\u0026lt;SPI.h\u0026gt;\u003C\/span\u003E\u003C\/span\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cspan class=\"hljs-keyword\" style=\"color: rgb(0 , 151 , 157);\"\u003Evoid\u003C\/span\u003E \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003Esetup\u003C\/span\u003E() {\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003ESPI\u003C\/span\u003E.\u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003Ebegin\u003C\/span\u003E();\u003Cbr \/\u003E  WriteAD9833(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E0x2100\u003C\/span\u003E); \u003Cspan class=\"hljs-comment\" style=\"color: rgba(149 , 165 , 166 , 0.8);\"\u003E\/\/0010 0001 0000 0000 - Reset + DB28\u003C\/span\u003E\u003Cbr \/\u003E  WriteAD9833(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E0x50C7\u003C\/span\u003E); \u003Cspan class=\"hljs-comment\" style=\"color: rgba(149 , 165 , 166 , 0.8);\"\u003E\/\/0101 0000 1100 0111 - Freq0 LSB (4295)\u003C\/span\u003E\u003Cbr \/\u003E  WriteAD9833(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E0x4000\u003C\/span\u003E); \u003Cspan class=\"hljs-comment\" style=\"color: rgba(149 , 165 , 166 , 0.8);\"\u003E\/\/0100 0000 0000 0000 - Freq0 MSB (0)\u003C\/span\u003E\u003Cbr \/\u003E  WriteAD9833(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E0xC000\u003C\/span\u003E); \u003Cspan class=\"hljs-comment\" style=\"color: rgba(149 , 165 , 166 , 0.8);\"\u003E\/\/1100 0000 0000 0000 - Phase0 (0)\u003C\/span\u003E\u003Cbr \/\u003E  WriteAD9833(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E0x2000\u003C\/span\u003E); \u003Cspan class=\"hljs-comment\" style=\"color: rgba(149 , 165 , 166 , 0.8);\"\u003E\/\/0010 0000 0000 0000 - Exit Reset\u003C\/span\u003E\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cspan class=\"hljs-keyword\" style=\"color: rgb(0 , 151 , 157);\"\u003Evoid\u003C\/span\u003E WriteAD9833(uint16_t Data){\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003ESPI\u003C\/span\u003E.beginTransaction(SPISettings(SPI_CLOCK_DIV2, MSBFIRST, SPI_MODE2));\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003EdigitalWrite\u003C\/span\u003E(SS, \u003Cspan class=\"hljs-literal\" style=\"color: rgb(211 , 84 , 0);\"\u003ELOW\u003C\/span\u003E);\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003EdelayMicroseconds\u003C\/span\u003E(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E1\u003C\/span\u003E);\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003ESPI\u003C\/span\u003E.transfer16(Data);\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003EdigitalWrite\u003C\/span\u003E(SS, \u003Cspan class=\"hljs-literal\" style=\"color: rgb(211 , 84 , 0);\"\u003EHIGH\u003C\/span\u003E);\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003ESPI\u003C\/span\u003E.endTransaction();\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cspan class=\"hljs-keyword\" style=\"color: rgb(0 , 151 , 157);\"\u003Evoid\u003C\/span\u003E \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003Eloop\u003C\/span\u003E() {\u003Cbr \/\u003E  WriteAD9833(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E0x2000\u003C\/span\u003E); \u003Cspan class=\"hljs-comment\" style=\"color: rgba(149 , 165 , 166 , 0.8);\"\u003E\/\/0010 0000 0000 0000 - Синусоидальный сигнал\u003C\/span\u003E\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003Edelay\u003C\/span\u003E(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E5000\u003C\/span\u003E);\u003Cbr \/\u003E  WriteAD9833(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E0x2002\u003C\/span\u003E); \u003Cspan class=\"hljs-comment\" style=\"color: rgba(149 , 165 , 166 , 0.8);\"\u003E\/\/0010 0000 0000 0010 - MODE=1 - Треугольный\u003C\/span\u003E\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003Edelay\u003C\/span\u003E(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E5000\u003C\/span\u003E);\u003Cbr \/\u003E  WriteAD9833(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E0x2020\u003C\/span\u003E); \u003Cspan class=\"hljs-comment\" style=\"color: rgba(149 , 165 , 166 , 0.8);\"\u003E\/\/0010 0000 0010 0000 - OPBITEN=1 - Прямоугольный (MSB\/2)\u003C\/span\u003E\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003Edelay\u003C\/span\u003E(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E5000\u003C\/span\u003E);\u003Cbr \/\u003E  WriteAD9833(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E0x2028\u003C\/span\u003E); \u003Cspan class=\"hljs-comment\" style=\"color: rgba(149 , 165 , 166 , 0.8);\"\u003E\/\/0010 0000 0010 1000 - OPBITEN=1, DIV2=1 - Прямоугольный (MSB)\u003C\/span\u003E\u003Cbr \/\u003E  \u003Cspan class=\"hljs-built_in\" style=\"color: rgb(211 , 84 , 0);\"\u003Edelay\u003C\/span\u003E(\u003Cspan class=\"hljs-number\" style=\"color: rgb(138 , 123 , 82);\"\u003E5000\u003C\/span\u003E);\u003Cbr \/\u003E }\u003C\/pre\u003E\u003Cbr \/\u003EВ данном скетче выполняются следующие действия:\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003EПри первом вызове функции WriteAD9833 производится установка управляющего регистра: бит RESET устанавливается в 1 для выполнения сброса; бит DB28 устанавливается в 1 для перезаписи всего содержимого регистра частоты; биты FSELECT и PSELECT содержат 0, поэтому для генерации выходного сигнала будут использоваться регистры FREQ0 и PHASE0.\u003C\/li\u003E\u003Cli\u003EСледующие два вызова передают значение 4295 в регистр частоты FREQ0. Данное значение умещается в 14 младших разрядах, поэтому в старшие разряды регистра записываем нули.\u003C\/li\u003E\u003Cli\u003EСдвиг по фазе не требуется - запишем в регистр PHASE0 значение 0\u003C\/li\u003E\u003Cli\u003EПоследним вызовом WriteAD9833 в процедуре setup снимаем бит RESET, разрешая тем самым работу генератора. Результирующий сигнал поступает на вывод VOUT.\u003C\/li\u003E\u003Cli\u003EСледующие вызовы WriteAD9833 в функции loop обновляют содержимое управляющего регистра, перебирая комбинации битов MODE, OPBITEN и DIV2 для генерации сигнала синусоидальной, треугольной и прямоугольной форм.\u003C\/li\u003E\u003C\/ul\u003EВот как выглядит выходной сигнал генератора в виртуальном осциллографе:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-vG7Kyb1PBSI\/WwW6w_75aNI\/AAAAAAAAAZs\/O-niM5ZaTj4Z3p9GvEi8aQebn9B2NhE0ACK4BGAYYCw\/s1600\/AD9833_sin.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" height=\"347\" src=\"https:\/\/4.bp.blogspot.com\/-vG7Kyb1PBSI\/WwW6w_75aNI\/AAAAAAAAAZs\/O-niM5ZaTj4Z3p9GvEi8aQebn9B2NhE0ACK4BGAYYCw\/s640\/AD9833_sin.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003EСинусоидальный сигнал (биты\u0026nbsp;MODE и\u0026nbsp;OPBITEN сброшены в 0)\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-CGtEk6UmWoU\/WwW63YFtX6I\/AAAAAAAAAZ0\/Ljzt-KCBqTYm6Se4Z8OTUw1xJqwxtmenACK4BGAYYCw\/s1600\/AD9833_tri.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" height=\"348\" src=\"https:\/\/2.bp.blogspot.com\/-CGtEk6UmWoU\/WwW63YFtX6I\/AAAAAAAAAZ0\/Ljzt-KCBqTYm6Se4Z8OTUw1xJqwxtmenACK4BGAYYCw\/s640\/AD9833_tri.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003EТреугольный сигнал (MODE = 1, OPBITEN = 0)\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/3.bp.blogspot.com\/-BLid2QyYDuQ\/WwW69XYCHaI\/AAAAAAAAAZ8\/eEH32LW-iSgkXWYUmRyP69W6axIL0G-9wCK4BGAYYCw\/s1600\/AD9833_MSBdiv2.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" height=\"348\" src=\"https:\/\/3.bp.blogspot.com\/-BLid2QyYDuQ\/WwW69XYCHaI\/AAAAAAAAAZ8\/eEH32LW-iSgkXWYUmRyP69W6axIL0G-9wCK4BGAYYCw\/s640\/AD9833_MSBdiv2.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003EПрямоугольный сигнал (OPBITEN = 1, MODE = 0, DIV2 = 1)\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003E\u003Ctable align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\" style=\"margin-left: auto; margin-right: auto; text-align: center;\"\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-N_aGK0opjiM\/WwW7BWtx5qI\/AAAAAAAAAaI\/Ry6MUKMMdF0roHgOL1-5sIRKkvFFiC8QgCK4BGAYYCw\/s1600\/AD9833_MSB.png\" imageanchor=\"1\" style=\"margin-left: auto; margin-right: auto;\"\u003E\u003Cimg border=\"0\" height=\"348\" src=\"https:\/\/2.bp.blogspot.com\/-N_aGK0opjiM\/WwW7BWtx5qI\/AAAAAAAAAaI\/Ry6MUKMMdF0roHgOL1-5sIRKkvFFiC8QgCK4BGAYYCw\/s640\/AD9833_MSB.png\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/td\u003E\u003C\/tr\u003E\u003Ctr\u003E\u003Ctd class=\"tr-caption\" style=\"text-align: center;\"\u003EПрямоугольный сигнал (OPBITEN = 1, MODE = 0, DIV2 = 0)\u003C\/td\u003E\u003C\/tr\u003E\u003C\/tbody\u003E\u003C\/table\u003E\u003Cbr \/\u003EОбратите внимание: при генерации синусоидальных и треугольных импульсов, когда сигнал снимается с выхода ЦАП, его амплитуда изменяется в диапазоне 38мВ...0,65В. При генерации импульсов прямоугольной формы мы имеем дело с обычным цифровым сигналом с соответствующими уровнями напряжения. Так в последних двух осциллограммах логической единице соответствует напряжение ~4,5В.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Ch3 style=\"text-align: left;\"\u003EГенератор на AD9833 с дисплеем и энкодером\u003C\/h3\u003E\u003Cdiv\u003EРазобравшись с управлением AD9833 можно приступать к созданию генератора с интерфейсом управления и индикацией. Для этого добавим в нашу схему энкодер вращения и жидкокристаллический дисплей:\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Ca href=\"http:\/\/4.bp.blogspot.com\/-nbGuCEW9QLo\/WyZuuKJXIEI\/AAAAAAAAAbY\/8CFdIHr9GCMlViToXqf7OEX_7Ass_IsfACK4BGAYYCw\/s1600\/AD9833_generator.png\" imageanchor=\"1\"\u003E\u003Cimg alt=\"Схема генератора на AD9833 с дисплеем и энкодером KY-040\" border=\"0\" height=\"466\" src=\"https:\/\/4.bp.blogspot.com\/-nbGuCEW9QLo\/WyZuuKJXIEI\/AAAAAAAAAbY\/8CFdIHr9GCMlViToXqf7OEX_7Ass_IsfACK4BGAYYCw\/s640\/AD9833_generator.png\" title=\"\" width=\"640\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Ca href=\"http:\/\/tsibrov.blogspot.com\/2018\/01\/arduino-text-menu.html\" target=\"_blank\"\u003EРанее\u003C\/a\u003E я писал о том, как можно сделать меню на Ардуино с энкодером вращения. И сейчас я взял такое меню за основу скетча, добавив в него функционал для работы с AD9833. Скачать скетч можно по \u003Ca href=\"http:\/\/clc.la\/ad9833_generator\" target=\"_blank\"\u003Eссылке\u003C\/a\u003E.\u003Cbr \/\u003E\u003Cbr \/\u003EПри включении питания AD9833 настраивается на генерацию синусоидального сигнала частотой 100Гц, соответствующая информация отображается на дисплее. Вращая ручку энкодера можно изменять его частоту, а при нажатии вызывается меню. В меню доступны следующие опции:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cul style=\"text-align: left;\"\u003E\u003Cli\u003EУстановка частоты (можно задать произвольное значение от 1 до 12,5МГц).\u003C\/li\u003E\u003Cli\u003EУстановка фазы (0 - 360°).\u003C\/li\u003E\u003Cli\u003EВыбор формы сигнала.\u003C\/li\u003E\u003Cli\u003EВыбор значения, на которое изменяется частота при вращении ручки энкодера.\u003C\/li\u003E\u003C\/ul\u003E\u003Cbr \/\u003EОстается только поместить все компоненты в подходящий корпус и получится законченное устройство. Результат работы в следующем ролике:\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003Ciframe allowfullscreen=\"\" class=\"YOUTUBE-iframe-video\" data-thumbnail-src=\"https:\/\/i.ytimg.com\/vi\/5NsUpivK9OU\/0.jpg\" frameborder=\"0\" height=\"532\" src=\"https:\/\/www.youtube.com\/embed\/5NsUpivK9OU?feature=player_embedded\" width=\"640\"\u003E\u003C\/iframe\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/div\u003E\u003C\/div\u003E\u003C\/div\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"https:\/\/tsibrov.blogspot.com\/feeds\/4256446582282147909\/comments\/default","title":"Комментарии к сообщению"},{"rel":"replies","type":"text/html","href":"https:\/\/tsibrov.blogspot.com\/2018\/06\/ad9833.html#comment-form","title":"Комментарии: 42"},{"rel":"edit","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/794788004739538112\/posts\/default\/4256446582282147909"},{"rel":"self","type":"application/atom+xml","href":"https:\/\/www.blogger.com\/feeds\/794788004739538112\/posts\/default\/4256446582282147909"},{"rel":"alternate","type":"text/html","href":"https:\/\/tsibrov.blogspot.com\/2018\/06\/ad9833.html","title":"Генератор сигналов на AD9833"}],"author":[{"name":{"$t":"Владимир"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/07943437233560370294"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"16","height":"16","src":"https:\/\/img1.blogblog.com\/img\/b16-rounded.gif"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https:\/\/4.bp.blogspot.com\/-tN6CdYwMg6s\/WyQMYhQrmVI\/AAAAAAAAAbA\/Mr2xHivY5dkQ95C8l6JXwj_KS1MYMSFDQCK4BGAYYCw\/s72-c\/AD9833.jpg","height":"72","width":"72"},"thr$total":{"$t":"42"}}]}});